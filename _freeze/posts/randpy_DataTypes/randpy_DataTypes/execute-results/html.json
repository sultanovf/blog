{
  "hash": "608ec48d9b3fdb1181173f270da54be9",
  "result": {
    "markdown": "---\ntitle: |\n  R & Python: Types of Data\\\n  {{< fa language >}} in German\n\ndescription: | \n  \\\"Ich bin nicht wirklich an Daten interessiert. Ich bin mehr an Informationen interessiert.\\\" - das ist von Seymour Cray. Um zu Informationen zu kommen, will ich aber erst die Daten verstehen;).\n\nauthor: \"Fazliddin Sultonov\"\ndate: \"2022-12-12\"\ntitle-block-banner: true\nhighlight-style: pygments\ncategories: [R, Python, Data Types, German]\n\n# Code execute options\nexecute: \n  echo: true\n  eval: true   # Include cell source code in rendered output\n\n# Output\nformat: \n  html:\n    # Links\n    link-external-icon: false\n    link-external-newwindow: true\n    #code-tools:\n    #  toggle: true\n    # Sections\n    toc: true\n    #toc-expand: true\n    toc-location: left\n    toc-title: \"Table of Contents\"\n    toc_float: true\n    theme: spacelab\n    engine: knitr\n    css: custom.css\n\n# Chunk Options\nknitr:\n  opts_chunk:\n    comment: \"#>\" \n    class-output: \"code-output\"\n    # class-source: \"code-output\"\n  opts_knit: \n    warning: false\n    error: false\n# bibliography\nbibliography: references.bib\nnocite: |\n  @*\n---\n\n\n![](datatype.jpg)\n\n\n::: {.cell}\n\n:::\n\n\n> Wer immer tut, was er schon kann, bleibt immer das, was er schon ist.\n>\n> --- Henry Ford\n\nZuerst kurze Darstellung, wie das Ganze hier aufgebaut ist, wie der Input(Codeblock), Output(Ergebnis), Hinweis, … aussehen, also die\n\n## Struktur\n\nDer Input und Output für R und Python können nebeneinander oder in Tabsets, wobei [R-Sourse in hellcyan]{style=\"background-color: lightcyan\"} und [Python-Sourse in gelb]{style=\"background-color: yellow\"} dargestellt werden. Zeilenanfang im Output ist mit `#>` belegt.\n\n::: panel-tabset\n# `<svg preserveAspectRatio=\"none\" aria-hidden=\"true\" role=\"img\" viewBox=\"0 0 581 512\" style=\"height:1em;width:1em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:steelblue;overflow:visible;position:relative;\"><path d=\"M581 226.6C581 119.1 450.9 32 290.5 32S0 119.1 0 226.6C0 322.4 103.3 402 239.4 418.1V480h99.1v-61.5c24.3-2.7 47.6-7.4 69.4-13.9L448 480h112l-67.4-113.7c54.5-35.4 88.4-84.9 88.4-139.7zm-466.8 14.5c0-73.5 98.9-133 220.8-133s211.9 40.7 211.9 133c0 50.1-26.5 85-70.3 106.4-2.4-1.6-4.7-2.9-6.4-3.7-10.2-5.2-27.8-10.5-27.8-10.5s86.6-6.4 86.6-92.7-90.6-87.9-90.6-87.9h-199V361c-74.1-21.5-125.2-67.1-125.2-119.9zm225.1 38.3v-55.6c57.8 0 87.8-6.8 87.8 27.3 0 36.5-38.2 28.3-87.8 28.3zm-.9 72.5H365c10.8 0 18.9 11.7 24 19.2-16.1 1.9-33 2.8-50.6 2.9v-22.1z\"/></svg>`{=html}\n\n::: code-r\n\n::: {.cell}\n\n```{.r .cell-code}\ncat(\"Hallo R Lover!\")\n#> Hallo R Lover!\n```\n:::\n\n:::\n\n# `<svg preserveAspectRatio=\"none\" aria-hidden=\"true\" role=\"img\" viewBox=\"0 0 448 512\" style=\"height:1em;width:1em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:steelblue;overflow:visible;position:relative;\"><path d=\"M439.8 200.5c-7.7-30.9-22.3-54.2-53.4-54.2h-40.1v47.4c0 36.8-31.2 67.8-66.8 67.8H172.7c-29.2 0-53.4 25-53.4 54.3v101.8c0 29 25.2 46 53.4 54.3 33.8 9.9 66.3 11.7 106.8 0 26.9-7.8 53.4-23.5 53.4-54.3v-40.7H226.2v-13.6h160.2c31.1 0 42.6-21.7 53.4-54.2 11.2-33.5 10.7-65.7 0-108.6zM286.2 404c11.1 0 20.1 9.1 20.1 20.3 0 11.3-9 20.4-20.1 20.4-11 0-20.1-9.2-20.1-20.4.1-11.3 9.1-20.3 20.1-20.3zM167.8 248.1h106.8c29.7 0 53.4-24.5 53.4-54.3V91.9c0-29-24.4-50.7-53.4-55.6-35.8-5.9-74.7-5.6-106.8.1-45.2 8-53.4 24.7-53.4 55.6v40.7h106.9v13.6h-147c-31.1 0-58.3 18.7-66.8 54.2-9.8 40.7-10.2 66.1 0 108.6 7.6 31.6 25.7 54.2 56.8 54.2H101v-48.8c0-35.3 30.5-66.4 66.8-66.4zm-6.7-142.6c-11.1 0-20.1-9.1-20.1-20.3.1-11.3 9-20.4 20.1-20.4 11 0 20.1 9.2 20.1 20.4s-9 20.3-20.1 20.3z\"/></svg>`{=html}\n\n::: code-py\n\n::: {.cell}\n\n```{.python .cell-code}\nprint(\"Hallo Python Lover!\")\n#> Hallo Python Lover!\n```\n:::\n\n:::\n:::\n\nWo ich was Wichtiges zusagen habe, habe ich dementsprechend gefärbt und markiert:\n\n::: {.callout-caution icon=\"false\" collapse=\"true\"}\n## Expand for more\n\nWenn die Sachen in R und Python nicht in den Vergleich gezogen werden und z.B. wenn ich nur eine Variable erzeuge oder Berechnungen ausführe, werden die Code-Blocks nicht gefärbt dargestellt.\n\n\n::: {.cell}\n\n```{.python .cell-code  code-fold=\"true\" code-summary=\"show the code\"}\n# Den Variablen a und b die Werte 42, 13 zuweisen und sie zusammen addieren\na = 42\nb = 13\na + b\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.code-output}\n#> 55\n```\n:::\n:::\n\n\nDas Paket `reticulate` hilft die in Python erzeugten Variablen weiterhin in R zu benutzen z.B. Berechnungen durchzuführen.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"show the code\"}\n# Die Variablen a und b miteinander multiplizieren\npy$a * py$b\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.code-output}\n#> [1] 546\n```\n:::\n:::\n\n:::\n\nWenn ich was lerne, schreibe ich mir auf oder mache ich mir Notizen, ist nicht jedermanns Sache;). Hier gebe ich nur das wieder, was ich bei meinem Lernen verstanden habe und hoffe, dass das ein oder anderem, der R oder Python lernen möchte, von Interesse/Nutzen sein könnte. Die grammatische und/oder orthographischen Fehler im Text bitte ich vorab zu entschuldigen;). In diesem Sinne stelle ich zunächst vor,\n\n## Worum es geht\n\nIn diesem Stück geht es darum, was die Typen von Daten sind, warum sie unterschieden werden. Mehr werde ich versuchen, zu zeigen wie R und Python mit Datentypen umgehen. Ich habe mich auf Wichtige aus Richtigen konzentriert und habe versucht, die Datentypen mir aufzunehmen, mit denen man auch meistens zu tun haben könnte. Auf solche Datentypen, über die ich erstmal gelesen habe, wahrscheinlich auch zukunftig nicht brauchen werde wie komplexe Datentypen oder solche Raw Typen in R oder byts in Python, habe keine Beachtung geschenkt. Wie gesagt, habe ich mein Lernfokus auf die Datentypen, die ich für gebräuchlch halte, gelegt.\\n\\n\n\nSo möchte ich aber zuerst kurz erälen,\n\n## Was die Datentypen sind\n\nEs geht darum, welche Unterscheidungsmöglichkeiten es zwischen verschiedenen Arten von Daten gibt und warum die Datentypen überhaupt unterschieden werden. Ich denke gleich an der Unterscheidung zwischen Zahlen und Zeichenketten, mit denen man im Alltag am meisten zu tun hat, wenn man mit Daten arbeitet. Die Unterscheidung ist auch insofern von Bedeutung, wenn wir mit den Daten weiter arbeiten, Berechnungen durchführen wollen. Dabei werden die Daten in Variablen gespeichert, damit das Programm diese Daten anprechen kann. Also der Komputer muss verstehen ob es sich z.B. um die Zahlen oder Text handelt, wenn er was damit anstellen muss. Diese Variable können wir in R oder Python **`Obkete`** nennen. Der Typ dieser Objekte bestimmt, auf welche Art und Weise die Daten gespeichert und dargestellt werden. So ermöglicht beispielweise der Typ *Integer* eine ganze Zahl 42 als z.B *var* zu speichern und diese Zahl wird durch das Objekt *var* repräsentiert. Im Gegensatz zu vielen Programmiersprachen muss man bei Python und R den Typ nicht angeben oder deklarieren. Sie emitteln automatisch, um welchen Typ es sich handelt, wenn man ein Objekt erstellt. Daher fallen sie unter **OOP**(*Object Oriented Programming*)-Programmiersprachen.\\n\n\nJetzt weiß ich mehr oder weniger, was Data Type ist `<svg aria-hidden=\"true\" role=\"img\" viewBox=\"0 0 512 512\" style=\"height:1em;width:1em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:indianred;overflow:visible;position:relative;\"><path d=\"M464 256A208 208 0 1 0 48 256a208 208 0 1 0 416 0zM0 256a256 256 0 1 1 512 0A256 256 0 1 1 0 256zm177.6 62.1C192.8 334.5 218.8 352 256 352s63.2-17.5 78.4-33.9c9-9.7 24.2-10.4 33.9-1.4s10.4 24.2 1.4 33.9c-22 23.8-60 49.4-113.6 49.4s-91.7-25.5-113.6-49.4c-9-9.7-8.4-24.9 1.4-33.9s24.9-8.4 33.9 1.4zM144.4 208a32 32 0 1 1 64 0 32 32 0 1 1 -64 0zm165.8 21.7c-7.6 8.1-20.2 8.5-28.3 .9s-8.5-20.2-.9-28.3c14.5-15.5 35.2-22.3 54.6-22.3s40.1 6.8 54.6 22.3c7.6 8.1 7.1 20.7-.9 28.3s-20.7 7.1-28.3-.9c-5.5-5.8-14.8-9.7-25.4-9.7s-19.9 3.8-25.4 9.7z\"/></svg>`{=html}. Im Folgenden handelt es sich um\n\n## Häufig verwendete Basic Data Types in Python und R\n\nWie ich oben gesagt habe, werden Daten sowohl in R als auch in Python als Objekte gespeichert. Jedes Objekt bekommt einen Namen durch Zuweisung eines Werts diesem Namen. So kann ich z.B. die Zahl 42 mit dem Namen *val*, oder das Wort \"world\" mit dem Namen *txt* speichern. R oder Python erkennt beispielweise, dass 42 eine Zahl ist, also numerisch. Diese Zahl kann als *Integer* dargestellt werden. Aber beim Speichern dieser numerischen Zahl verhalten sich Python und R anders, R speichert sie als *numeric*, was Gleitkommazahl oder Float ist. Wenn ich die Zahl als Integer haben will, muss ich R dazu zwingen. Python macht umgekehrt, speichert diese Zahl als *int*, wenn ich als Float haben will, muss ich den Typ angeben bzw umwandeln.\\\nHier ist ein Überblick über die gängigen Basic Data Types in Python und R [In Anlehnung an @WouterCo]:\n\n| `<svg preserveAspectRatio=\"none\" aria-hidden=\"true\" role=\"img\" viewBox=\"0 0 581 512\" style=\"height:2em;width:2em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:steelblue;overflow:visible;position:relative;\"><path d=\"M581 226.6C581 119.1 450.9 32 290.5 32S0 119.1 0 226.6C0 322.4 103.3 402 239.4 418.1V480h99.1v-61.5c24.3-2.7 47.6-7.4 69.4-13.9L448 480h112l-67.4-113.7c54.5-35.4 88.4-84.9 88.4-139.7zm-466.8 14.5c0-73.5 98.9-133 220.8-133s211.9 40.7 211.9 133c0 50.1-26.5 85-70.3 106.4-2.4-1.6-4.7-2.9-6.4-3.7-10.2-5.2-27.8-10.5-27.8-10.5s86.6-6.4 86.6-92.7-90.6-87.9-90.6-87.9h-199V361c-74.1-21.5-125.2-67.1-125.2-119.9zm225.1 38.3v-55.6c57.8 0 87.8-6.8 87.8 27.3 0 36.5-38.2 28.3-87.8 28.3zm-.9 72.5H365c10.8 0 18.9 11.7 24 19.2-16.1 1.9-33 2.8-50.6 2.9v-22.1z\"/></svg>`{=html} | Example                            | `<svg preserveAspectRatio=\"none\" aria-hidden=\"true\" role=\"img\" viewBox=\"0 0 448 512\" style=\"height:2em;width:2em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:steelblue;overflow:visible;position:relative;\"><path d=\"M439.8 200.5c-7.7-30.9-22.3-54.2-53.4-54.2h-40.1v47.4c0 36.8-31.2 67.8-66.8 67.8H172.7c-29.2 0-53.4 25-53.4 54.3v101.8c0 29 25.2 46 53.4 54.3 33.8 9.9 66.3 11.7 106.8 0 26.9-7.8 53.4-23.5 53.4-54.3v-40.7H226.2v-13.6h160.2c31.1 0 42.6-21.7 53.4-54.2 11.2-33.5 10.7-65.7 0-108.6zM286.2 404c11.1 0 20.1 9.1 20.1 20.3 0 11.3-9 20.4-20.1 20.4-11 0-20.1-9.2-20.1-20.4.1-11.3 9.1-20.3 20.1-20.3zM167.8 248.1h106.8c29.7 0 53.4-24.5 53.4-54.3V91.9c0-29-24.4-50.7-53.4-55.6-35.8-5.9-74.7-5.6-106.8.1-45.2 8-53.4 24.7-53.4 55.6v40.7h106.9v13.6h-147c-31.1 0-58.3 18.7-66.8 54.2-9.8 40.7-10.2 66.1 0 108.6 7.6 31.6 25.7 54.2 56.8 54.2H101v-48.8c0-35.3 30.5-66.4 66.8-66.4zm-6.7-142.6c-11.1 0-20.1-9.1-20.1-20.3.1-11.3 9-20.4 20.1-20.4 11 0 20.1 9.2 20.1 20.4s-9 20.3-20.1 20.3z\"/></svg>`{=html} | Example                            |                Description |\n|:--------------|:--------------|:--------------|:--------------|--------------:|\n| [integer]{style=\"color: blue;\"}                                                | [42L]{style=\"color: red;\"}         | [int]{style=\"color: blue;\"}                                                | [42]{style=\"color: red;\"}          |               ganze Zahlen |\n| [numeric]{style=\"color: blue;\"}                                                | [42.33]{style=\"color: red;\"}       | [float]{style=\"color: blue;\"}                                              | [42.33]{style=\"color: red;\"}       | reelle Zahlen, Kommazahlen |\n| [character]{style=\"color: blue;\"}                                              | [\"Text\"]{style=\"color: red;\"}      | [str]{style=\"color: blue;\"}                                                | [\"Text\"]{style=\"color: red;\"}      |       Zeichenketten, Texte |\n| [logical]{style=\"color: blue;\"}                                                | [TRUE, FALSE]{style=\"color: red;\"} | [bool]{style=\"color: blue;\"}                                               | [True, False]{style=\"color: red;\"} |               ganze Zahlen |\n\n: {tbl-colwidths=\"\\[14,18,12,17,39\\]\"}\n\nAus der Tabelle kann ich sagen, dass ich mit drei grundlegenden gängigen Datentypen in Python und R am meisten zu tun habe. Das sind: **numerische** - zusammengesetzt aus *Integer* und *Float*, **logische** und **textuelle** Datentypen.\\n\n\nJetzt gehen wir einzelne Typen durch.\n\n### integer/int\n\nInteger stellt eine ganze Zahl dar, z.B. 7, -7. In R wird die ganze Zahl mit einem `L` hinter der Zahl gekennzeichnet. Warum L dahinter stehen soll, weiß auch nicht;). R soll ja bekanntlich auf Programmiersprache C aufgebaut sein und da soll L für *long integer* stehen. In Python werden die ganze Zahlen normal als integer gespeichert.\n\n::: {layout=\"[[50,50], [100]]\"}\n::: code-r\n***R***\n\n\n::: {.cell}\n\n```{.r .cell-code}\nri1 <- 11L\nri2 <- -12L\nri3 <- 13.0\nri4 <- \"123\"\nprint(class(ri1))\n#> [1] \"integer\"\nprint(class(ri2))\n#> [1] \"integer\"\nprint(class(ri3))\n#> [1] \"numeric\"\nprint(class(ri4))\n#> [1] \"character\"\n```\n:::\n\n:::\n\n::: code-py\n***Python***\n\n\n::: {.cell}\n\n```{.python .cell-code}\npi1 = 11\npi2 = -12\npi3 = 13.0\npi4 = \"123\"\nprint(type(pi1))\n#> <class 'int'>\nprint(type(pi2))\n#> <class 'int'>\nprint(type(pi3))\n#> <class 'float'>\nprint(type(pi4))\n#> <class 'str'>\n```\n:::\n\n:::\n:::\n\nUm herauszufinden oder anzeigen zu lassen, welchen Typ ein Objekt hat, gibt es Funktion ***`class()`*** in R und ***`type()`*** in Python. In R werden Objekte mit **`<-`** und in Python mit **`=`** zugewiesen. Generell geht eas auch in R mit `=`, aber mit Pfeil ist üblich\n\n::: {.callout-note collapse=\"true\"}\n## More about assignment in R: `<-` or `=` ?\n\nIn R ist üblich, Objekte mit `<-` zuzuweisen, während man in Python mit `=` zuweist. Generell geht auch in R mit Gleichheitszeichen. Aber man bevorzugt Zuweisungspfeil. Gleichheitszeichen wird zur Zuweisung eher innerhalb einer Funktion benutzt. Hier eine kleine Demonstration:\\\nDen Vektor von 1 bis 15 weise ich *vec* zu und rechne ich Summe:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(vec = 1:9)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.code-output}\n#> [1] 45\n```\n:::\n:::\n\n\nWenn ich das Objekt *vec* abfrage, kommt Fehlermeldung, weil dieses Objekt nur in der Funktion existiert:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(vec)\n```\n\n::: {.cell-output .cell-output-error}\n```\n#> Error in eval(expr, envir, enclos): Objekt 'vec' nicht gefunden\n```\n:::\n:::\n\n\nDas Gleiche mache ich mit `<-`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(vec <- 1:9)\n#> [1] 45\nprint(vec)\n#> [1] 1 2 3 4 5 6 7 8 9\n```\n:::\n\n\nDer Zuweisungspfeil wird aber meistens empfohlen und verwendet. Hier zum Nachlesen: [Style guide von Hadley Wickham](http://adv-r.had.co.nz/Style.html) und hier: [Google’s R Style Guide](https://google.github.io/styleguide/Rguide.html)\n:::\n\n**`<svg preserveAspectRatio=\"none\" aria-hidden=\"true\" role=\"img\" viewBox=\"0 0 581 512\" style=\"height:2em;width:2em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:steelblue;overflow:visible;position:relative;\"><path d=\"M581 226.6C581 119.1 450.9 32 290.5 32S0 119.1 0 226.6C0 322.4 103.3 402 239.4 418.1V480h99.1v-61.5c24.3-2.7 47.6-7.4 69.4-13.9L448 480h112l-67.4-113.7c54.5-35.4 88.4-84.9 88.4-139.7zm-466.8 14.5c0-73.5 98.9-133 220.8-133s211.9 40.7 211.9 133c0 50.1-26.5 85-70.3 106.4-2.4-1.6-4.7-2.9-6.4-3.7-10.2-5.2-27.8-10.5-27.8-10.5s86.6-6.4 86.6-92.7-90.6-87.9-90.6-87.9h-199V361c-74.1-21.5-125.2-67.1-125.2-119.9zm225.1 38.3v-55.6c57.8 0 87.8-6.8 87.8 27.3 0 36.5-38.2 28.3-87.8 28.3zm-.9 72.5H365c10.8 0 18.9 11.7 24 19.2-16.1 1.9-33 2.8-50.6 2.9v-22.1z\"/></svg>`{=html} $~~$ -- $~~$ Prüfen, ob der Typ des Objekts integer ist**\\\nIn R kann man den Typ des Objekts durch die Funktion ***`is.integer()`*** oder ***`inherits(object, \"type\")`*** prüfen.\n\n::: code-r\n***R***\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Check in R if a number is integer\nis.integer(ri1)            # Is 11L integer?\n#> [1] TRUE\ninherits(ri2, \"integer\")   # Is -12 integer?\n#> [1] TRUE\nis.integer(ri3)            # Is 13.0 integer?\n#> [1] FALSE\nis.integer(ri4)            # Is \"123\" integer?\n#> [1] FALSE\ninherits(ri4, \"character\") # Is \"123\"character?\n#> [1] TRUE\n```\n:::\n\n:::\n\n**-- in integer umwandeln**\\\nWie gesagt, ohne L speichert R die Zahl als numeric, also als Kommazahl bzw. Float *(Sieh Objekt ri3 im BSP oben)*. Ich muss R dazu bringen, dass er die Zahl als Integer behandelt. Dafür kann ich die Funktion ***`as.integer()`*** benutzen.\n\n::: code-r\n***R***\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"show the code\" code-line-numbers=\"true\"}\n# Making R treat the object as an integer\nprint(class(ri3))              # Type of 13.0\nprint(class(ri4))              # Type of \"123\"\nprint(class(as.integer(ri3)))  # Forsing 13.0 to integer\nprint(class(as.integer(ri3)))  # Forsing \"123\" to integer\nprint(class(FALSE))            # Type of FALSE\nprint(class(TRUE))             # Type of True\nprint(as.integer(FALSE))       # FALSE as Integer\nprint(as.integer(TRUE))        # TRUE as Integer\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.code-output}\n#> [1] \"numeric\"\n#> [1] \"character\"\n#> [1] \"integer\"\n#> [1] \"integer\"\n#> [1] \"logical\"\n#> [1] \"logical\"\n#> [1] 0\n#> [1] 1\n```\n:::\n:::\n\n:::\n\n**`<svg preserveAspectRatio=\"none\" aria-hidden=\"true\" role=\"img\" viewBox=\"0 0 448 512\" style=\"height:2em;width:2em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:steelblue;overflow:visible;position:relative;\"><path d=\"M439.8 200.5c-7.7-30.9-22.3-54.2-53.4-54.2h-40.1v47.4c0 36.8-31.2 67.8-66.8 67.8H172.7c-29.2 0-53.4 25-53.4 54.3v101.8c0 29 25.2 46 53.4 54.3 33.8 9.9 66.3 11.7 106.8 0 26.9-7.8 53.4-23.5 53.4-54.3v-40.7H226.2v-13.6h160.2c31.1 0 42.6-21.7 53.4-54.2 11.2-33.5 10.7-65.7 0-108.6zM286.2 404c11.1 0 20.1 9.1 20.1 20.3 0 11.3-9 20.4-20.1 20.4-11 0-20.1-9.2-20.1-20.4.1-11.3 9.1-20.3 20.1-20.3zM167.8 248.1h106.8c29.7 0 53.4-24.5 53.4-54.3V91.9c0-29-24.4-50.7-53.4-55.6-35.8-5.9-74.7-5.6-106.8.1-45.2 8-53.4 24.7-53.4 55.6v40.7h106.9v13.6h-147c-31.1 0-58.3 18.7-66.8 54.2-9.8 40.7-10.2 66.1 0 108.6 7.6 31.6 25.7 54.2 56.8 54.2H101v-48.8c0-35.3 30.5-66.4 66.8-66.4zm-6.7-142.6c-11.1 0-20.1-9.1-20.1-20.3.1-11.3 9-20.4 20.1-20.4 11 0 20.1 9.2 20.1 20.4s-9 20.3-20.1 20.3z\"/></svg>`{=html} $~~$ -- $~~$ Prüfen, ob der Typ des Objekts int ist**\nUm zu prüfen gibt es in Python auch mehrere Wege: durch die Funktion ***`isinstance(object, type)`*** (wie `inherits(object, \"\"type\")` bei R) oder kann mann auch prüfen, indem man den Objekttyp dem Datentyp gleichsetzt z.B. ***`type(objekt) ==/is int()`***. Es gibt auch die Funktion ***`is_integer()`***. Diese Funktion ist zum Checken, ob Float vom Typ Integer ist, bei anderer Typen funktioniert nicht, zumindest tat bei mir nicht. Außerdem braucht man dafür Modul sumpy, denkeich, worauf ich hier verzichtet habe. Daher habe ich nicht tief gesucht, denn ich kenne ja schon einen Weg, der nach Rom führt. `<svg aria-hidden=\"true\" role=\"img\" viewBox=\"0 0 512 512\" style=\"height:1em;width:1em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:indianred;overflow:visible;position:relative;\"><path d=\"M464 256A208 208 0 1 0 48 256a208 208 0 1 0 416 0zM0 256a256 256 0 1 1 512 0A256 256 0 1 1 0 256zm177.6 62.1C192.8 334.5 218.8 352 256 352s63.2-17.5 78.4-33.9c9-9.7 24.2-10.4 33.9-1.4s10.4 24.2 1.4 33.9c-22 23.8-60 49.4-113.6 49.4s-91.7-25.5-113.6-49.4c-9-9.7-8.4-24.9 1.4-33.9s24.9-8.4 33.9 1.4zM144.4 208a32 32 0 1 1 64 0 32 32 0 1 1 -64 0zm165.8 21.7c-7.6 8.1-20.2 8.5-28.3 .9s-8.5-20.2-.9-28.3c14.5-15.5 35.2-22.3 54.6-22.3s40.1 6.8 54.6 22.3c7.6 8.1 7.1 20.7-.9 28.3s-20.7 7.1-28.3-.9c-5.5-5.8-14.8-9.7-25.4-9.7s-19.9 3.8-25.4 9.7z\"/></svg>`{=html}\n\n::: code-py\n***Python***\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Check in Python if a number is integer\nisinstance(pi1, int) # Is 11 integer?\n#> True\ntype(pi2) == int     # Is -12 integer?\n#> True\nisinstance(pi3, int) # Is 13.0 integer?\n#> False\ntype(pi4) is int     # Is '123' integer?\n#> False\n```\n:::\n\n:::\n\n**-- in int umwandeln**\\\nPython speichrt die Zahlen als Integer. Wenn ich sie als Float will, muss ich den Typ umwandeln in Float. Wenn ich Daten von Typ z.B. Text, Float oder Logical habe, kann ich ihn umwandeln in Integer in Python, indem ich Objekt in die Funktion ***`int()`*** übergebe.\n\n::: code-py\n***Python***\n\n\n::: {.cell}\n\n```{.python .cell-code  code-fold=\"true\" code-summary=\"show the code\" code-line-numbers=\"true\"}\n# Making Python treat the object as an integer\nprint(type(pi3))        # Type of 13.0\nprint(type(pi4))        # Type of \"123\"\nprint(type(int(pi3)))   # Forsing 13.0 to integer\nprint(type(int(pi3)))   # Forsing \"123\" to integer\nprint(type(False))      # Type of FALSE\nprint(type(True))       # Type of True\nprint(int(False))       # FALSE as Integer\nprint(int(True))        # TRUE as Integer\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.code-output}\n#> <class 'float'>\n#> <class 'str'>\n#> <class 'int'>\n#> <class 'int'>\n#> <class 'bool'>\n#> <class 'bool'>\n#> 0\n#> 1\n```\n:::\n:::\n\n:::\n\n### numeric/float\n\nDie Kommazahlen mit Nachkommastellen sind die Floats. R speichert die Zahlen normalerweise als Float (ohne diese L nach der Zahl). Generell werden Zahlen in R als `numeric` dargestellt. Sie können auch Integer oder Float sein. Beispielweise speichert R die Zahl 10 als Float, mit der Funktion `class()` stellt er den Typ als *`numeric`* dar. Es gibt auch noch eine Funktion in R, mit der man den Typ prüfen kann: ***`typeof()`***. Diese gibt den Typ von 10 als `double` an, vermutlich kommt das auch von der C Sprache. Ich denke, durchs folgende Beispiel wird deutlicher, was ich meine;).\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"show the code\" code-line-numbers=\"true\"}\n# class() und typeof()\nclass(10)    # numeric\ntypeof(10)   # double\nclass(10L)   # integer\ntypeof(10L)  # integer\nclass(10.0)  # numeric\ntypeof(10.0) # double\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.code-output}\n#> [1] \"numeric\"\n#> [1] \"double\"\n#> [1] \"integer\"\n#> [1] \"integer\"\n#> [1] \"numeric\"\n#> [1] \"double\"\n```\n:::\n:::\n\n\n**-- Prüfen, ob der Typ des Objekts numeric/float ist**\\\nWie beim Integer, kann man hier auch ähnliche Funktionen benutzen ***`is.numeric()`*** oder ***`is.double()`*** oder auch `inherits(obj, \"type\")` für R, und gleiche wie oben für Python.\n\n::: {layout=\"[[50,50], [100]]\"}\n::: code-r\n***R***\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrf1 <- 3.14\nrf2 <- 17\nrf3 <- 20L\nprint(class(rf2))  # class()-Type of 17\n#> [1] \"numeric\"\nprint(class(rf3))  # class()-Type of 20L\n#> [1] \"integer\"\nprint(typeof(rf2)) # typeof()-Type of 17\n#> [1] \"double\"\nprint(typeof(rf3)) # typeof()-Type of 20L\n#> [1] \"integer\"\nis.numeric(rf1)    # Is 3.14 numeric?\n#> [1] TRUE\nis.double(rf2)     # Is 17 double?\n#> [1] TRUE\nis.numeric(rf3)    # Is 20L numeric?\n#> [1] TRUE\nis.integer(rf3)    # Is 20L integer?\n#> [1] TRUE\n```\n:::\n\n:::\n\n::: code-py\n***Python***\n\n\n::: {.cell}\n\n```{.python .cell-code}\npf1 = 3.14\npf2 = 17\npf3 = 20\nprint(type(pf1))      # Type of 3.14\n#> <class 'float'>\nprint(type(pf2))      # Type of 17\n#> <class 'int'>\nprint(type(pf3))      # Type of 20\n#> <class 'int'>\nisinstance(pf1, float)# Is 3.14 float?\n#> True\nisinstance(pf1, int)  # Is 3.14 int?\n#> False\ntype(pf2) is float    # Is 17 float?\n#> False\ntype(pf3) == float    # Is 20 float?\n#> False\nisinstance(pf2, float)# Is 17 float?\n#> False\n```\n:::\n\n:::\n:::\n\n**-- in numeric/float umwandeln**\\\nDas Gleiche gilt auch hier, wenn ich den Datentyp in numeric oder float haben will.\\\nIn R benutze ich dafur die Funktion ***`as.numeric()`*** oder ***`as.double`***.\n\n::: code-r\n***R***\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"show the code\" code-line-numbers=\"true\"}\n# Making R treat the object as an integer\nprint(class(rf2))              # Type of 17\nprint(class(rf3))              # Type of 20L\nprint(class(as.numeric(rf2)))  # Forsing 17 to nomeric\nprint(class(as.double(rf3)))   # Forsing 20L to nomeric\nprint(as.numeric(FALSE))       # FALSE as numeric\nprint(as.double(TRUE))         # TRUE as numeric\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.code-output}\n#> [1] \"numeric\"\n#> [1] \"integer\"\n#> [1] \"numeric\"\n#> [1] \"numeric\"\n#> [1] 0\n#> [1] 1\n```\n:::\n:::\n\n:::\n\nIn Python kann ich dies mit der Funktion ***`float()`*** anstellen.\n\n::: code-py\n***Python***\n\n\n::: {.cell}\n\n```{.python .cell-code  code-fold=\"true\" code-summary=\"show the code\" code-line-numbers=\"true\"}\n# Making Python treat the object as an integer\nprint(type(pf2))        # Type of 17\nprint(type(pf3))        # Type of 20\nprint(type(float(pf2))) # Forsing 17 to float\nprint(type(float(pf3))) # Forsing 20 to float\nprint(float(False))     # FALSE as float\nprint(float(True))      # TRUE as float\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.code-output}\n#> <class 'int'>\n#> <class 'int'>\n#> <class 'float'>\n#> <class 'float'>\n#> 0.0\n#> 1.0\n```\n:::\n:::\n\n:::\n\n### character/str\n\nWie der Name schon sagt, solche Daten sind Strings, die Zeichen, Buchstaben enthalten. In R werden sie als `character` und in Python als `str` charakteresiert. Mit Strings hat man in der Praxis auch wie mit numerischen Daten häufig zu tun. Beispielweise können im zu analysierenden Datensatz auch kategoriale Variablen: \"männlich\", \"weiblich\" vorhanden sein usw.\\\nStrings können im doppelten Apostroph `'text'` oder in Anführungszeichen oder Gänsefüßchen `\"text\"` angegeben werden/sein in R auch in Python. Die Funktion für die Länge des Strings ist für R: ***`nchar()`*** und für Python ***`len()`***.\n\n::: panel-tabset\n# `<svg preserveAspectRatio=\"none\" aria-hidden=\"true\" role=\"img\" viewBox=\"0 0 581 512\" style=\"height:1em;width:1em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:steelblue;overflow:visible;position:relative;\"><path d=\"M581 226.6C581 119.1 450.9 32 290.5 32S0 119.1 0 226.6C0 322.4 103.3 402 239.4 418.1V480h99.1v-61.5c24.3-2.7 47.6-7.4 69.4-13.9L448 480h112l-67.4-113.7c54.5-35.4 88.4-84.9 88.4-139.7zm-466.8 14.5c0-73.5 98.9-133 220.8-133s211.9 40.7 211.9 133c0 50.1-26.5 85-70.3 106.4-2.4-1.6-4.7-2.9-6.4-3.7-10.2-5.2-27.8-10.5-27.8-10.5s86.6-6.4 86.6-92.7-90.6-87.9-90.6-87.9h-199V361c-74.1-21.5-125.2-67.1-125.2-119.9zm225.1 38.3v-55.6c57.8 0 87.8-6.8 87.8 27.3 0 36.5-38.2 28.3-87.8 28.3zm-.9 72.5H365c10.8 0 18.9 11.7 24 19.2-16.1 1.9-33 2.8-50.6 2.9v-22.1z\"/></svg>`{=html}\n\n::: code-r\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"true\"}\n# Examples for Characters\nrt1 <- \"123\"\nrt2 <- \"Hello\" \nrt3 <- \"World\"\nglue::glue(\"Class of rt1: {class(rt1)}\")\n# Adding Strings \nglue::glue(\"Mit der Funktion glue(): {rt2} {rt3}\")\npaste(\"Mit der Funktion paste():\", rt2, rt3, sep = \" \")\n# Compare Strings\nrt2 == \"Hello\"\nrt2 == \"HELLO\"\nrt1 == 123\n# Length of String\nglue(\"Länge von \\\"123\\\": {nchar(rt1)}\")\nglue(\"Länge von \\\"Hello\\\": {nchar(rt2)}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.code-output}\n#> Class of rt1: character\n#> Mit der Funktion glue(): Hello World\n#> [1] \"Mit der Funktion paste(): Hello World\"\n#> [1] TRUE\n#> [1] FALSE\n#> [1] TRUE\n#> Länge von \"123\": 3\n#> Länge von \"Hello\": 5\n```\n:::\n:::\n\n:::\n\nR hat es schwer mit Zusammenaddieren von Strings und multiplizieren von Strings mit einer Zahl.\n\n::: {.callout-note collapse=\"true\"}\n## More about string operations in R\n\nWenn man in R zwei Strings zusammen addieren will oder String mit einer Zahl multiplizieren will, gibt R Error zurück, also kann es nicht. Vielleich gibt es irgendein Paket, das dies ermöglichen, müsste man mal schauen. Also einfach Addieren von zwei Strings wie in Python geht in R nicht. Mit der Funktion ***`glue()`*** aus dem Paket `glue` oder mit der Funktion `paste` konnte ich zwei Strings zusammen addierend anzeigen lassen. Diese Funktion gibt es auch im Paket `stringr` kann so angewendet werden: `stringr::str_glue()`. Die Funktion `glue(\"The value of text is {text})` ist wie f-String in Python `print(f\"The value of text is {text}\")`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrt1 + rt2\n#> Error in rt1 + rt2: nicht-numerisches Argument für binären Operator\nrt3 * 3\n#> Error in rt3 * 3: nicht-numerisches Argument für binären Operator\n```\n:::\n\n:::\n\n# `<svg preserveAspectRatio=\"none\" aria-hidden=\"true\" role=\"img\" viewBox=\"0 0 448 512\" style=\"height:1em;width:1em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:steelblue;overflow:visible;position:relative;\"><path d=\"M439.8 200.5c-7.7-30.9-22.3-54.2-53.4-54.2h-40.1v47.4c0 36.8-31.2 67.8-66.8 67.8H172.7c-29.2 0-53.4 25-53.4 54.3v101.8c0 29 25.2 46 53.4 54.3 33.8 9.9 66.3 11.7 106.8 0 26.9-7.8 53.4-23.5 53.4-54.3v-40.7H226.2v-13.6h160.2c31.1 0 42.6-21.7 53.4-54.2 11.2-33.5 10.7-65.7 0-108.6zM286.2 404c11.1 0 20.1 9.1 20.1 20.3 0 11.3-9 20.4-20.1 20.4-11 0-20.1-9.2-20.1-20.4.1-11.3 9.1-20.3 20.1-20.3zM167.8 248.1h106.8c29.7 0 53.4-24.5 53.4-54.3V91.9c0-29-24.4-50.7-53.4-55.6-35.8-5.9-74.7-5.6-106.8.1-45.2 8-53.4 24.7-53.4 55.6v40.7h106.9v13.6h-147c-31.1 0-58.3 18.7-66.8 54.2-9.8 40.7-10.2 66.1 0 108.6 7.6 31.6 25.7 54.2 56.8 54.2H101v-48.8c0-35.3 30.5-66.4 66.8-66.4zm-6.7-142.6c-11.1 0-20.1-9.1-20.1-20.3.1-11.3 9-20.4 20.1-20.4 11 0 20.1 9.2 20.1 20.4s-9 20.3-20.1 20.3z\"/></svg>`{=html}\n\n::: code-py\n\n::: {.cell}\n\n```{.python .cell-code  code-line-numbers=\"true\"}\n# Examples for Characters\npt1 = \"123\"\npt2 = \"Hello\" \npt3 = \"world\"\nprint(f\"Type of pt1: {type(pt1)}\")\n# Adding Strings\nprint(pt2 + \" \" + pt3) # or\nprint(f\"{pt2} {pt3}\")\n# Multiply a string by 3\npt3*3\n# Compare\npt2 == \"Hello\"\npt2 == \"HELLO\"\npt1 == 123\n# Length of String\nprint(f\"Länge von \\\"123\\\": {len(pt1)}\")\nprint(f\"Länge von \\\"Hallo\\\": {len(pt2)}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.code-output}\n#> Type of pt1: <class 'str'>\n#> Hello world\n#> Hello world\n#> 'worldworldworld'\n#> True\n#> False\n#> False\n#> Länge von \"123\": 3\n#> Länge von \"Hallo\": 5\n```\n:::\n:::\n\n:::\n:::\n\nStrings sing ein umfangreiches Thema. Hier waren nur Sachen bezogen auf Datentyp. Vielleicht wird es zudem ein separates Notizbuch geben `<svg aria-hidden=\"true\" role=\"img\" viewBox=\"0 0 512 512\" style=\"height:1em;width:1em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:indianred;overflow:visible;position:relative;\"><path d=\"M464 256A208 208 0 1 0 48 256a208 208 0 1 0 416 0zM0 256a256 256 0 1 1 512 0A256 256 0 1 1 0 256zm177.6 62.1C192.8 334.5 218.8 352 256 352s63.2-17.5 78.4-33.9c9-9.7 24.2-10.4 33.9-1.4s10.4 24.2 1.4 33.9c-22 23.8-60 49.4-113.6 49.4s-91.7-25.5-113.6-49.4c-9-9.7-8.4-24.9 1.4-33.9s24.9-8.4 33.9 1.4zM144.4 208a32 32 0 1 1 64 0 32 32 0 1 1 -64 0zm165.8 21.7c-7.6 8.1-20.2 8.5-28.3 .9s-8.5-20.2-.9-28.3c14.5-15.5 35.2-22.3 54.6-22.3s40.1 6.8 54.6 22.3c7.6 8.1 7.1 20.7-.9 28.3s-20.7 7.1-28.3-.9c-5.5-5.8-14.8-9.7-25.4-9.7s-19.9 3.8-25.4 9.7z\"/></svg>`{=html}.\n\n### logical/bool\n\nDie Objekt vom logischen Typ können die Werte WAHR/FALSCH oder 1/0 annehmen. Diese werden in R als `logical` und in Python als `bool` gespeichert. Schreibweisen unterscheiden sich auch, geschrieben bzw. dargestellt werden sie in R mit Großbuchstaben: [TRUE/FALSE]{style=\"color: red;\"} und in Python klein geschrieben mit Großbuchstaben am Anfang: [True/False]{style=\"color: red;\"}.\n\n::: {layout=\"[[50,50], [100]]\"}\n::: code-r\n***R***\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrt <- TRUE\nrf <- FALSE\nclass(rt)        # Type of TRUE\n#> [1] \"logical\"\nclass(rf)        # Type of FALSE\n#> [1] \"logical\"\nis.logical(rt)   # Is TRUE logical\n#> [1] TRUE\nas.character(rt) # TRUE as character\n#> [1] \"TRUE\"\nas.character(rf) # FALSE as character\n#> [1] \"FALSE\"\nas.integer(rt)   # TRUE as integer\n#> [1] 1\nas.integer(rf)   # FALSE as integer\n#> [1] 0\nrt & rf          # rt AND rf\n#> [1] FALSE\nrt | rf          # rt OR rf\n#> [1] TRUE\n!rt              # Is not TRUE\n#> [1] FALSE\n```\n:::\n\n:::\n\n::: code-py\n***Python***\n\n\n::: {.cell}\n\n```{.python .cell-code}\npt = True\npf = False\ntype(pt)  # Type of True\n#> <class 'bool'>\ntype(pf)  # Type of False\n#> <class 'bool'>\ntype(pt) is bool # Is bool\n#> True\nstr(pt)   # True as String\n#> 'True'\nstr(pf)   # False as String\n#> 'False'\nint(pt)   # True as Integer\n#> 1\nint(pf)   # False as Integer\n#> 0\npt and pf # pt AND pf\n#> False\npt or pf  # pt OR pf\n#> True\nnot pt    # Is not True\n#> False\n```\n:::\n\n:::\n:::\n\nSoo, am Ziel angekommen;). Hoffentlich ist mir gelungen, meine Notizen einigermaßen verständänlich und anständig darzustellen `<svg aria-hidden=\"true\" role=\"img\" viewBox=\"0 0 512 512\" style=\"height:1em;width:1em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:indianred;overflow:visible;position:relative;\"><path d=\"M464 256A208 208 0 1 0 48 256a208 208 0 1 0 416 0zM0 256a256 256 0 1 1 512 0A256 256 0 1 1 0 256zm177.6 62.1C192.8 334.5 218.8 352 256 352s63.2-17.5 78.4-33.9c9-9.7 24.2-10.4 33.9-1.4s10.4 24.2 1.4 33.9c-22 23.8-60 49.4-113.6 49.4s-91.7-25.5-113.6-49.4c-9-9.7-8.4-24.9 1.4-33.9s24.9-8.4 33.9 1.4zM144.4 208a32 32 0 1 1 64 0 32 32 0 1 1 -64 0zm165.8 21.7c-7.6 8.1-20.2 8.5-28.3 .9s-8.5-20.2-.9-28.3c14.5-15.5 35.2-22.3 54.6-22.3s40.1 6.8 54.6 22.3c7.6 8.1 7.1 20.7-.9 28.3s-20.7 7.1-28.3-.9c-5.5-5.8-14.8-9.7-25.4-9.7s-19.9 3.8-25.4 9.7z\"/></svg>`{=html}.\n\n## References\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}